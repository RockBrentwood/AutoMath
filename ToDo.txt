Extensions (both planned and envisioned):
âˆ™	Support for UTF-8 so that mathematical notation can be more directly conveyed; e.g.:
		âˆ§, âˆ¨, âŠƒ, âŠ‚, âŠ¢, âŠ£, âˆ€, âˆƒ, âŠ¤, âŠ¥, â‰¡, â‰¢, =, â‰ , â‰¤, â‰¥, â†’, â†, â†”, etc.;
	instead of:
		And, Or, IfThen, Unless, Infer, Defer, All, Any, Yea, Nay, Iff, Xor, Is, Isnt, LessEq, MoreEq, To, From, ToFrom, etc.
âˆ™	Prefix, infix and postfix syntax for affix operators, the same way that Prolog implements them;
	(i.e. the fx/fy/xf/yf/xfx/xfy/yfx operator types with numeric precedence).
	to allow for notation like Câˆ§A, A âŠ¢ B, Â¬B, instead of âˆ§(C,A), âŠ¢(A,B), Â¬(B), etc.
âˆ™	Support for bracketing, itself, as an operator, similar to Prolog's.
âˆ™	Addition of product types (both tuples/lists).
âˆ™	Support for deBruijn's "telescoping", in conjunction with multivariate abstractions and applications.
âˆ™	Collating of declarations
	Example:
		pred A, B, C;
	instead of
		pred A; pred B; pred C;
	or
		pred A, B â†¦ pred Aâˆ§B, Aâˆ¨B;
	instead of
		pred A, pred B â†¦ pred Aâˆ§B;
		pred A, pred B â†¦ pred Aâˆ¨B;
âˆ™	Syntax remade more into as C/C++ style; with support for legacy syntax confined to conversion utilities.
	Conversion will include AUT-Î”Î  in its scope, as well as AUT-68 and AUT-QE;
	sufficiently comprehensive to allow the AUT-Î”Î  that Automath can currently produce to be converted.
âˆ™	Operator overloading.
âˆ™	Type inheritance/inclusion hierarchy: because deBruijn kept calling for it in his references.
âˆ™	Inclusion of a "typeof" primitive that works consistently with the type inheritance/inclusion;
	because deBruijn called out the gap created by its absence (in his example code) and effectively called for its inclusion by virtue of this.
âˆ™	Expansion of "paragraphs" into full-fledged modules, with "public" and "private" access for the components of a module.
âˆ™	Separation of the "compilation" and "linking" phases.
âˆ™	A "conjecture"/"lemma" line = a "definition" line without a defining expression -
	which may be used for issuing external declarations which a module implements.
	This requires a post-processing during the linking phase to check for cyclic dependencies.
âˆ™	The *direct* inclusion of a *native* recursion facility by allowing for limited forms of cyclic dependencies;
	by-passing the need for any "recursion" object -
âˆ™	Stratification of hypothesis into 1, 2 or more layers of context to allow for more explicit specification of polymorphism;
	with support for a minimum of two levels of parametrization:
	â€•	Hindley-Martin polymorphism parameters - which Automath's parametrization is grandfathered into,
	â€•	Explicit parameters.
	Example:
		A, B, C: pred â”‚ f: Câˆ§A âŠ¢ B â†¦ Î› f: C âŠ¢ AâŠƒB;
	instead of
		A, B, C: pred, f: Câˆ§A âŠ¢ B â†¦ Î›(A,B,C,f): C âŠ¢ AâŠƒB;
âˆ™	Polymorphic parameters are matched by unification rather than by exactly matching them to the names used in their definition.
	This means that when an operator is defined by
		Tâ‚€ xâ‚€, Tâ‚(xâ‚€) xâ‚, Tâ‚‚(xâ‚€,xâ‚) xâ‚‚, â‹¯ @ Uâ‚€ yâ‚€, Uâ‚(yâ‚€) yâ‚, Uâ‚‚(yâ‚€,yâ‚) yâ‚‚, â‹¯ â†¦ T(ğ±,ğ²) Op(ğ²) = Ex(ğ±,ğ²)
	with polymorphism parameters ğ± and explicit parameters ğ², then the ğ±'s in a call to Op(ğ…) are processed,
	based on the surrounding context, using unification to produce the most general unifier Ïƒ: ğ±â†¦ğ„,
	and then to apply the Î´-rule to equate Op(ğ…) = Ex(ğ„,ğ…) = Ex(Ïƒğ±,ğ…).
âˆ™	A posisble facility for explicitly listing polymorphic parameters, e.g. Î›Â«A,B,CÂ» f for Î›(A,B,C,f) when it is desired to make A, B and C explicit.
	A possible specification for the default ordering of polymorphic parameters.
âˆ™	Automatic/default determination of contexts ... from context.
	e.g.
		f: Câˆ§A âŠ¢ B â†¦ Î› f: C âŠ¢ AâŠƒB;
	instead of
		A, B, C: pred â”‚ f: Câˆ§A âŠ¢ B â†¦ Î› f: C âŠ¢ AâŠƒB;
	where the context (A, B, C: pred) is inferred solely from the requirement that f: Câˆ§A âŠ¢ B and Î› f: C âŠ¢ AâŠƒB be well-formed.
âˆ™	A built-in facility for equational-logic sufficiently powerful
	to make it possible to implement reduction systems (like Martin-LÃ¶f's).
	A reduction system may be implemented as a "higher-level" language (or "superposed language" as deBruijn called it)
	which compiles into a series of equational steps in AutoMath in a manner analogous to an abstraction algorithm in the Lambda calculus.
âˆ™	Alternatively: native support for equational logic sufficiently large to embody some of the primitives of more contemporary higher-order type systems.
	This includes:
	â€•	Possible unflattening the conflation of indexed product types and lambda abstractions
			[T x: E]	â‡’	(âˆx:T) E, when E is a type
			[T x: E]	â‡’	(Î»x:T) E, when E is an expression
		and support for the "implication" type T â†’ E = (Î x:T) E, when type E is independent of x.
	â€•	Possible inclusion of support for an indexed sum type (Î£x:T) E;
		and support for the "conjunction" type T âˆ§ E = (Î£x:T) E, when type E is independent of x.

As seen in the GrundLagen.aut test file, the current version of AutoMath inherits the somewhat-broken implementation of âŠƒ, Â¬, âˆ€ and âˆƒ
seen in here in the following specificaiton which it implements:
	A, B: prop â†¦ A âŠƒ B = [A â†’ B]: prop;
	A, B: prop â”‚ a: A, i: A âŠƒ B â†¦ Mp(a,i) = i<a>: B;
	â†¦ âŠ¥: prop;
	A: prop â†¦ Â¬ A = A âŠƒ âŠ¥, Â¬Â² A = Â¬ Â¬ A: prop;
	A: prop â”‚ a: A â†¦ Â¬Â²â†‘ a = (Î»x: Â¬ A) x<a>: Â¬Â² A;
	A: prop â”‚ w: Â¬Â² A â†¦ Â¬Â²â†“ w: A;
	A: prop â”‚ c: âŠ¥ â†¦ Â¬â†“ c = Â¬Â²â†“ (Î»x: Â¬ A) c: A;

	S: type â”‚ P: [S â†’ prop] â†¦ âˆ€ P = P: prop;
	S: type, P: [S â†’ prop] â”‚ a: âˆ€Â«SÂ» P, s: S â†¦ âˆ€â†“(a,s) = a<s>: P<s>;
	S: type, P: [S â†’ prop] â”‚ s: S, n: Â¬ P<s> â†¦ âˆ€âˆ·Th1(s,n) = (Î»x: âˆ€Â«SÂ» P) n<x<s>>: Â¬ âˆ€Â«SÂ» P;

	S: type, P: [S â†’ prop] â”‚ âˆ„ P = (Î s:S) Â¬ P<s>: [S â†’ prop];
	S: type, P: [S â†’ prop] â”‚ âˆƒ P = Â¬ âˆ„ P: prop;
	S: type, P: [S â†’ prop] â”‚ s: S, Ps: P<s> â†¦ âˆƒâ†‘(s,Ps) = âˆ€âˆ·Th1(s, Â¬Â²â†‘ Ps): âˆƒ P;
when we should have something more like this:
	S: type â”‚ P: [S â†’ prop] â†¦ âˆ€ P: prop;
	S: type, P: [S â†’ prop] â”‚ a: âˆ€ P â†¦ âˆ€â†“ a = (Î»s: S) a<s>: P;
	S: type, P: [S â†’ prop] â”‚ a: âˆ€ P, s: S â†¦ âˆ€â†“(a,s) = (âˆ€â†“ a)<s>: P<s>;
	S: type, P: [S â†’ prop] â”‚ s: S, n: Â¬ P<s> â†¦ âˆ€âˆ·Th1(s,n) = (Î»x: âˆ€ P) n<(âˆ€â†“ x)<s>>: Â¬ âˆ€ P;

	S: type â”‚ P: [S â†’ prop] â†¦ âˆ„ P = âˆ€ (Î s:S) Â¬ P<s>: prop;
	S: type â”‚ P: [S â†’ prop] â†¦ âˆƒ P = Â¬ âˆ„ P: prop;
	S: type, P: [S â†’ prop] â”‚ s: S, Ps: P<s> â†¦ âˆƒâ†‘(s,Ps) = âˆ€âˆ·Th1(s, Â¬Â²â†‘ Ps): âˆƒ P;
